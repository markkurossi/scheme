;;;
;;; Copyright (c) 2022 Markku Rossi
;;;
;;; All rights reserved.
;;;

(runner 'run "characters"
        (lambda (t)
          (letrec ((iter
                    (lambda (values)
                      (if (null? values)
                          #t
                          (begin
                            (if (not (eq? (caar values) (cadar values)))
                                (t 'error "character mismatch"))
                            (iter (cdr values)))))))
            (iter '((#\a 		#\x61)
                    (#\A 		#\x41)
                    (#\( 		#\x28)
                    (#\  		#\x20)
                    (#\nul 		#\x00)
                    (#\alarm		#\x07)
                    (#\backspace	#\x08)
                    (#\tab		#\x09)
                    (#\linefeed		#\x0a)
                    (#\newline		#\x0a)
                    (#\vtab		#\x0b)
                    (#\page		#\x0c)
                    (#\return		#\x0d)
                    (#\esc		#\x1b)
                    (#\space		#\x20)
                    (#\delete		#\x7f)
                    (#\xFF		#\xff)
                    (#\x03bb		#\x03bb)
                    (#\x00006587	#\x6587)
                    (#\xA		#\xa)
                    (#\xFF		#\xFF)
                    (#\xff		#\xFF)
                    )))))
(runner 'run "char?"
        (lambda (t)
          (if (not (char? #\a))
              (t 'error "char? #\a")))
        (lambda (t)
          (if (char? 'a)
              (t 'error "char? 'a")))
        (lambda (t)
          (if (char? #t)
              (t 'error "char? #t")))
        (lambda (t)
          (if (char? "foo")
              (t 'error "char? \"foo\"")))
        (lambda (t)
          (if (char? 42)
              (t 'error "char? 42")))
        (lambda (t)
          (if (char? cons)
              (t 'error "char? cons")))
        )

(runner 'run "char->integer"
        (lambda (t)
          (if (not (= (char->integer #\return) #x0d))
              (t 'error "char->integer #\return")))
        (lambda (t)
          (if (not (= (char->integer (integer->char 5000)) 5000))
              (t 'error "integer->char->integer")))
        (lambda (t)
          (if (not (eq? (integer->char 32) #\space))
              (t 'error "integer->char 32"))))
(runner 'run "char predicates"
        (lambda (t)
          (if (not (char=? (integer->char 32) #\space #\ ))
              (t 'error "char=?")))
        (lambda (t)
          (if (not (char=? #\space #\ ))
              (t 'error "char=?")))
        (lambda (t)
          (if (not (char=? #\space #\ #\x20))
              (t 'error "char=?")))
        (lambda (t)
          (if (char=? #\space #\x21)
              (t 'error "char=?")))

        (lambda (t)
          (if (not (char<? #\a #\b))
              (t 'error "char<?")))
        (lambda (t)
          (if (not (char<? #\a #\b #\c))
              (t 'error "char<?")))
        (lambda (t)
          (if (char<? #\a #\a)
              (t 'error "char<?")))

        (lambda (t)
          (if (not (char>? #\b #\a))
              (t 'error "char>?")))
        (lambda (t)
          (if (not (char>? #\c #\b #\a))
              (t 'error "char>?")))
        (lambda (t)
          (if (char>? #\a #\a)
              (t 'error "char>?")))

        (lambda (t)
          (if (not (char<=? #\a #\b))
              (t 'error "char<=?")))
        (lambda (t)
          (if (not (char<=? #\a #\b #\c))
              (t 'error "char<=?")))
        (lambda (t)
          (if (not (char<=? #\a #\b #\c #\c))
              (t 'error "char<=?")))
        (lambda (t)
          (if (char<=? #\b #\a)
              (t 'error "char<=?")))

        (lambda (t)
          (if (not (char>=? #\b #\b))
              (t 'error "char>=?")))
        (lambda (t)
          (if (not (char>=? #\c #\b #\a))
              (t 'error "char>=?")))
        (lambda (t)
          (if (not (char>=? #\c #\b #\a #\a))
              (t 'error "char>=?")))
        (lambda (t)
          (if (char>=? #\a #\b)
              (t 'error "char>=?")))
        )
